---
layout: post
title:  "论文阅读：拥挤场景中的端到端人物检测"
date:   2019-02-10
categories: [论文]
tags: [Paper, Deep Learning, Object Detection]
---

CVPR 2016

Paper: [End-to-end people detection in crowded scenes](https://www.cv-foundation.org/openaccess/content_cvpr_2016/html/Stewart_End-To-End_People_Detection_CVPR_2016_paper.html)

## Abstract
* 目前的人物检测器的操作方式有两种，即要么**以滑动窗口方式扫描图像**或者**对一组离散的提议进行分类**。 
* 我们提出了一种基于将图像解码为一组人物检测的模型。 我们的系统**将一幅640*480的图像作为输入**，并直接**输出一组不同的人物检测框（detection hypotheses）**。 
* 因为我们联合生成预测，所以不需要例如非极大值抑制（non-maximum suppression）的常规公共后处理步骤。 我们**使用一个循环的 LSTM 层进行序列生成**，并使用了一个新的损失函数对模型进行端到端训练，该**损失函数对整个检测集合起作用**。 
* 最后，我们展示了该方法在拥挤场景中检测人这一富有挑战性任务上的有效性。

**（关于模型细节可以直接跳到 3 Implementation details 的太长不看部分）**

## 1 Introduction
提出了一种用于检测图像中的对象的新架构
* 一种端到端的方法，接受图像作为输入，并直接生成一组对象边界框作为输出
    * 这个任务具有挑战性，因为需要区分对象和背景，并正确估计不同对象的数量和位置
    * 但这种直接输出检测的端到端方法优于传统方法：即首先生成一组边界框，再用分类器评价它们，最后对过完备检测集合（an overcomplete set of detections ）执行某种形式的合并或非极大值抑制
    
* 顺序生成一组检测具有重要的优点，即通过记住先前生成的输出避免对同一对象的多次检测。
![网络架构](https://ws4.sinaimg.cn/large/006tKfTcly1g0vsxyg0dlj312k0c476z.jpg)
    * 为了控制这个生成过程，使用具有 LSTM 单元的 RNN。 
    * 为了产生中间表示，使用来自 GoogLeNet 的图像特征，这些特征作为系统的一部分进一步 微调（ﬁne-tuned）。
    * 因此，我们的架构可以被看作是将图像的中间表示转换成一组预测对象的“解码”过程。 LSTM 可被视为在解码步骤之间传播信息并控制下一个输出的位置的“控制器”。
* 重要的是，可端到端训练的系统允许通过反向传播对所有组件进行联合调整。

解决对象重叠问题
* 传统方法中的后处理步骤（合并和非极大值抑制）的主要局限性：这些方法通常不访问图片信息，而是仅根据边界框的属性（例如距离和重叠）执行推断，因此在对象少不重叠时管用，但对象实体重叠时通常失效。
* 有几种解决方案提出预定义对象 constellations （例如行人对）
* 本文提出一个通用架构，不需要专门定义对象 constellations，不限于对象对，并且完全可训练。
    
本文的主要贡献：
* 一种联合预测图像中的对象的可训练的端到端方法。这与现有方法将每个边界框的预测或分类视为独立问题并需要对检测集合进行后处理的现有方法相反。 我们证明了我们的方法在富有挑战性的包含有大量人物的拥挤场景数据集上优于现有的架构。
* 本文的技术贡献是一个针对目标集的新颖的损失函数，结合了 localization and detection。 
* 另一个技术贡献是表明可以成功地利用 LSTM 序列将图像内容解码成可变长度的相干实值输出。
* 我们预见这种技术在其他结构化计算机视觉预测任务中很有价值，例如多人物追踪和多人物关节姿态估计。

### 1.1 Related work
存在遮挡的情况下检测多个物体一直是计算机视觉中一个臭名昭著（notorious）的问题。
* 早期工作：需要复杂的调整和多阶段流水线，基于局部特征的弱表示不如 modern deep representations
* 尝试预测 constellations of objects 的方法：不够 general
* 目前，性能最佳的目标检测器通过滑动窗口密集地扫描图像，或通过 CNN 对稀疏的区域建议分类。两种方法都产生描述包含对象的图像区域的边界框，然后通过合并严重重叠的实例来修剪网络输出。 这适用于具有少量不重叠的对象实例的图像，但在强遮挡的情况下通常会失败。
    * Faster R-CNN 学习类独立的建议，然后用 CNN 进行分类。与 Faster R-CNN 一样，我们从图像中提出了一组边界框，但这些提议直接对应于对象实例，不需要后处理。 Faster R-CNN 的输出必然是稀疏的，而我们的系统能够以产生任意近距离对象的检测。
* 本文的方法与OverFeat模型有关，即依靠回归模块从 CNN 编码生成框。 但是，我们的例子中，不同的框是作为集成过程的一部分生成的，而不是像 OverFeat 中那样独立生成。 因此，每个输出框直接对应于图像中检测到的对象，并且我们不需要合并或非最大抑制等后处理。 我们的方法的另一个重要优点是它输出对应于端到端训练的每个输出的置信度。 在OverFeat的情况下，端到端训练的信息预测不可用，因为输出是启发式合并过程的结果。
* 本文的工作与[25]有关，因为我们模型中的训练目标共同考虑了对多个对象实例的检测。主要区别在于我们的模型在测试时联合生成输出边界框，允许它正确检测强遮挡的对象。
* 本文依靠 LSTM 来预测可变长度输出。与语言生成不同，检测要求系统在2D输出空间上生成，其缺乏自然的线性排序。
    * MultiBox 通过引入一种损失函数来解决这一挑战，该函数允许无序预测在训练期间进行排列以匹配 ground truth 实例[21]。
    * Faster R-CNN 通过将对象划分为具有9个具有3个尺度和3个纵横比的类别来解决这一挑战，允许网络直接产生多个重叠对象，前提是它们具有不同的大小[16]。
    * 本文基于这些贡献，利用循环解码器的能力来按顺序进行联合预测。除了计算预测与 ground truth 的最佳匹配之外，我们的损失函数还鼓励模型按照自信度下降的顺序进行预测。

## 2 Model
### 2.1 Overview
深度表示具有足够的能力来 jointly encode the appearance of multiple instances，但是必须使用用于多实例预测的组件来增强它们以实现这种潜力。本文中，考虑使用 RNN，特别是 LSTM 单元。

使深度 CNN 与基于 RNN 的解码器结合的关键优势是：
1. 能够直接利用强大的深度卷积表示;
2. 能够生成可变长度的相干预测集。

在我们的情况下，生成相干集的能力尤为重要，因为我们的系统需要记住先前生成的预测并避免对同一目标进行多次预测。

我们构建了一个模型，该模型首先通过卷积架构将图像编码为高级表示，然后将该表示解码为一组边界框。作为预测可变长度输出的核心机制，我们建立了 LSTM 单元的 RNN。

流水线：
* 将每个图像转换为整个图像中 strided regions 的1024维特征描述符的网格。
    * 1024维向量总结了该区域的内容，并携带有关对象位置的丰富信息。 
* LSTM从该信息源中提取并充当区域解码中的控制器。
    * 在每个步骤中，LSTM输出一个新的边界框和相应的置信度，以便在该位置找到先前未检测到的人。
    * 边界框将按照以置信度降序生成。
    * 当LSTM无法在区域内找到另一个具有高于预定阈值的信号时，会产生停止符号。
* 收集输出序列并将其呈现为该区域中所有对象实例的最终描述。

我们方法中的主要计算流程仅涉及前馈处理，这允许快速实现。在现代GPU上，该方法在640x480图像上以每秒6帧的速度运行。

### 2.2 Loss function
假设是按顺序生成的，并且随后的预测通过LSTM的存储器状态取决于先前的预测。

在每次重复时，LSTM输出一个对象边界框 $b = \{b_{pos}, b_c\}$，
* $b_{pos} = (b_x, b_y, b_w, b_h) ∈ \mathbb{R}^4$ 是边界框的相对位置，宽度和高度
* $b_c ∈ [0, 1]$ 是置信度的真值

低于预定阈值（例如0.5）的置信度值在测试时将被解释为停止符号。较高的边界框置信度b_c应该指示该边界框更可能对应于真阳性。

我们将相应的标准真值边界框集合表示为 $G = \{ b^i \| i = 1, ..., M \}$，并且由模型生成的候选边界框集合为 $C = \{b^j \| j = 1, ..., N\}$。接下来，引入适合于将学习过程引导到期望输出的损失函数。

![](https://ws1.sinaimg.cn/large/006tKfTcly1g0vt0re9hgj30vu0c0q4i.jpg)

考虑上图的例子，它示意性地显示出了具有四个生成假设的检测器，每个假设由其预测步骤编号，我们以秩（rank）表示。

注意典型的检测错误，如假阳性（假设3），不精确的定位（假设1）和同一真值实例的多重预测（假设1和2）。不同的错误需要不同种类的反馈。
* 在假设1的情况下，边框位置必须被微调。
* 假设3是假阳性，模型应当通过设置低置信度得分来丢弃这个预测。
* 假设2是对已经由假设1预测过的目标的第二次预测，也应该被丢弃。

为了捕捉这些关系，我们引入一个匹配算法，为每个标准真值分配唯一的候选假设。该算法返回单射函数 $ f：G→C $，即 $ f(i) $ 是分配给标准真值假设i的候选假设的索引。

给定 $ f $，我们在集合 $ G $ 和 $ C $ 上定义损失函数：

$ L(G, C, f) = \alpha  \sum_{i=1}^{\|G\|} l_{pos}(b_{pos}^i, \tilde{b}\_{pos}^{f(i)}) + \sum\_{i=1}^{\|C\|} l_c(\tilde{b}_c^j, y_j) $

其中
* $ l_{pos} = \|\| b_{pos}^i - \tilde{b}_{pos}^{f(i)}\|\|_1 $ 是标准真值位置和候选假设之间的位移
* $ l_c $ 是候选框置信度的交叉熵损失，它将与标准真值进行匹配。该交叉熵损失的标签由 $ y_j $ 提供，它由匹配函数 $ y_j = \mathbb{1} \{f^{-1}(j) \neq \phi \} $ 定义得到：
* $ \alpha $ 是置信度误差和定位误差之间的折衷项。我们交叉验证设置 $ \alpha = 0.03 $。
* 注意，对于固定匹配，我们可以通过反向传播这个损失函数的梯度来更新网络。
作为一个原始基线，我们考虑一个基于标准真值边界框的固定顺序的简单匹配策略。我们通过图像位置从上到下和从左到右排序标准真值框。该固定顺序匹配序列化地将候选者分配给排好序的标准真值。我们将这个匹配函数称为“固定顺序”匹配，将其表示为 $ L_{fix} $，与其对应的损失函数表示为 $ L_{fix} $。

**匈牙利损失**：

固定顺序匹配的限制是当解码过程产生假阳性或假阴性时，它可能不正确地将候选假设分配给标准真值实例。对于f_fix选择的任何特定顺序，此问题仍然存在。因此，我们研究考虑C和G中元素之间所有可能的一对一分配的损失函数。

回想一下，我们的模型的原则性目标之一是输出对多个对象的连贯的预测序列。我们将生成过程的停止标准定义为当预测分数低于指定阈值时产生。
* 对于这样的分数阈值来说，要使其有意义，我们必须鼓励模型在序列的早期生成正确的假设，并避免在高置信度之前产生低置信度预测。
* 因此，当两个假设都有效地和同一真值实例重叠时（例如，图3中的假设1和2），我们优选匹配在预测序列中较早出现的假设。

为了形式化这个概念，我们引入以下假设与标准真值的比较函数：
$ \Delta(b_i, \tilde{b}\_j) = (o\_{ij}, r_j, d_{ij}) $

函数 $ \Delta: G×C → \mathbb{N} × \mathbb{N} × \mathbb{R} $ 返回一个元组，其中
* $ d_{ij} $ 是边界框位置之间的L1距离
* $ r_j $ 是LSTM输出的预测序列中的b_j的秩或索引
* $ o_{ij} ∈ \{0, 1\} $ 是假设与标准真值实例不充分重叠的惩罚变量。这里，重叠标准要求候选者的中心要位于标准真值边界框的范围内。$ o_{ij} $ 变量明确区分定位和检测错误。
* 我们定义了一个由 $ \Delta $ 产生的元组的词典顺序。也就是说，当评估两个假设中的哪一个将被分配给标准真值时，重叠是最重要的，随后是秩，然后再是细粒度定位。

给定方程2中的比较函数 $ \Delta $ 的定义，我们通过匈牙利算法在多项式时间内找到 $ C $ 和 $ G $ 之间的最小成本二分匹配。注意，匈牙利算法适用于具有明确定义的加法和成对比较运算的带边权的任何图。为此，我们定义 $(+)$ 作为元素相加，$(<)$ 作为词典比较。对于图3中的例子，正确匹配假设1和4将花费（0, 5, 0.4），而匹配1和3将花费（1, 4, 2.3），匹配2和4将花费（0, 6, 0.2）。注意，用于检测重叠的第一项是如何适当地处理那些尽管具有低秩，但离标准真值差太远而不足以成为敏感匹配的假设的情况（如图3中的假设3的情况）。我们将这种匹配的相应损失称为匈牙利损失，并表示为 $ L_{hung} $。

我们还考虑 $ L_{hung} $ 的简化版本，其中只有来自 $ C $ 的排名前 $ k = \| G \| $ 的预测被考虑用于匹配。 注意，这等效于去除或置零方程2中的成对匹配项 $ o_{ij} $。 我们将此损失表示为 $L_{firstk}$。 在第4节，我们在实验上比较了$L_{fix}$，$L_{firstk}$和$ L_{hung} $，结果显示$ L_{hung} $效果最好。

**损失函数分析**
我们的网络几乎在所有地方都是可微的（DAE），因为它是DAE函数的组合。 在匹配是局部恒定的邻域中，$ L_{hung} $也是DAE。此外，该匹配在最佳匹配成本为其中任何其他匹配并且所有重叠项严格控制的点的邻域中将是恒定的。 在实践中，这将发生在每次训练的迭代，所以我们有信心使用梯度下降。

## 3 Implementation details

### 太长不看版本 by Piddnad
![网络架构](https://ws4.sinaimg.cn/large/006tKfTcly1g0vsxyg0dlj312k0c476z.jpg)
* 输入是 640*480 图像，使用 GoogLeNet 将图像编码成 1024维 15x20大小 的高层特征
    * 每个特征单元具有大小为139×139的感受野
* 使用 LSTM 作为控制器，顺序生成检测
    * 通过记住先前生成的输出，避免对同一对象的多次检测
    * 使用 300 个带 LSTM 单元的 RNN，对应网格中的 300 个 1x1x1024 单元
    * 每个 RNN 包括 5 个 LSTM 单元（因为在数据集中，很少有区域有超过4个实例，因此每个区域限制为5个预测）
* 鼓励 LSTM 将每一个 真值边界框 和 候选预测边界框 建立一一映射，每个1x1x1024 单元按照置信度从高到低输出至多5个预测框

### 原文
我们构建了我们的模型，将图像编码成1024维GoogLeNet高层特征的15x20大小的网格。网格中的每个单元具有大小为139×139的感受野，并且被训练以产生与中心64×64区域相交的所有边界框的集合。选择64x64大小，足够大以捕获具有挑战性的局部遮挡相互作用。也可以使用更大的区域，但是在我们这个场景上几乎不能提供额外的帮助，因为很少的遮挡相互作用能够跨越该尺度。 300个不同的LSTM控制器并行运行着，每个对应着网格中的1x1x1024单元。

我们的LSTM单元有250个存储器状态，没有偏置项，没有非线性输出。在每一步，我们将GoogLeNet特性与前一个LSTM单元的输出连接，并将结果馈送到下一个LSTM单元。我们已经通过仅将图像馈送到第一LSTM单元中产生可比较的结果，指出图像的多个呈现可能不是必要的。通过并行地产生完整480×640图像的每个区域，给出了解码过程的有效批处理。

我们的模型必须通过LSTM解码器学习在边界框位置上进行回归。 在训练期间，解码器输出边界框的过完备集合，每个边界框具有对应的置信度。为了简单和批处理效率，过完备集的基数是固定的，而不考虑标准真值框的数量。 这样可以训练LSTM对那些和标准真值接近的框输出高置信度分数和正确定位，而在其他地方输出低置信度分数。因为在匹配期间优先考虑前面的输出，所以模型学习首先输出高置信度，容易的边界框。 在我们的数据集中，很少有区域有超过4个实例，我们将过完备集限制为5个预测。更大数量的预测既不改善性能，也不降低性能。

模型训练：　我们使用Caffe开源深度学习框架[10]进行训练和评估。我们模型的解码器部分是一个定制的LSTM实现。我们使用学习率e= 0.2和动量0.5训练。梯度被修剪以在网络上具有0.1的最大2范数。 我们每100,000次迭代将学习率降低为0.8倍。在800,000次迭代达到收敛。我们在LSTM输出上使用概率为0.15的dropout(随机失活)。去掉dropout会减少平均精度（AP）0.01。

每次迭代时，训练在一个图像的所有子区域上进行。跨区域的LSTM解码器的并行性降低了较大批量大小的效率增益。所有权重在区域和LSTM步骤之间绑定。然而，当每一步使用单独的权重连接LSTM输出来预测候选时，我们很惊讶地发现有轻微的性能提高。这些权重在各区域之间保持固定。绑定这些权重，AP会从0.85减少到0.82。

初始化：GoogLeNet权重用Imagenet [3]上预先训练的权重初始化。微调GoogLeNet的特征以满足解码器的新需求至关重要。没有GoogLeNet微调的训练将使AP减少0.29。

解码器中的所有权重用范围在[-0.1,0.1]的均匀分布初始化。典型的LSTM输入激活与我们预训练的GoogLeNet显著不同，激活在[-80,80]范围内。为了补偿这种不匹配，我们使用一个缩放层将GoogLeNet激活减少100倍，然后将它们导入LSTM。同样，全连接层输出的初始标准偏差约为0.3，但边界框像素位置和大小在[-64,64]中变化。因此，在将回归预测与标准真值比较之前，我们将其乘以因子100。注意，只有当还引入了比例学习速率乘法器时，这些修改才与改变权重初始化等价。

拼接：我们的算法被训练来预测64x64像素区域内的多个边界框。要在测试时将其应用于完整的640x480大小的图像，我们会从图像的15×20网格中的每个区域生成预测，然后使用拼接算法递归地合并网格上连续单元格的预测。

拼接过程如图4所示。在给定的迭代中，令A表示当前所有已接受的边界框预测的集合。我们处理一个新的区域，评估解码器直到产生停止信号并收集新提出的边界框的集合C。这些新的边界框中的一些可能和先前的预测有重合。为了去除对同一对象的多次预测，我们定义了与2.2节中的具有成对损失项Δ'的二分匹配问题：$A×C→\mathbb{N} × \mathbb{R}$，给定$Δ '(b_i,b_j) = (m_{ij}, d_{ij})$。这里，$m_{ij}$表示两个框是否不相交，并且$d_{ij}$是由框之间的L1距离给出的局部消歧项。如前所述，我们利用匈牙利算法在多项式时间内找到最小成本匹配。我们检查每个匹配对 $(b, \tilde{b})$，并将不与其匹配项 $b$ 重叠的任何候选项 $\tilde{b}$ 添加到接受框的集合。这个过程和非极大值抑制之间的重要区别是（1）来自相同区域的框不会相互抑制，（2）每个框最多可以抑制一个其他框。连带地，这允许对实例生成预测，即使它们在图像中明显重叠。

## 4 模型效果展示
![](https://ws4.sinaimg.cn/large/006tKfTcly1g0vt1svilij30u00whqga.jpg)
上图将本文的模型和 Faster R-CNN 的检测结果进行比较。

* 第一行是未经过非极大值抑制处理的 Faster R-CNN 输出，可以看到对于同一个目标产生了多个冗余检测框；
* 第二行是经过非极大值抑制处理的 Faster R-CNN 输出，可以看到对于重叠目标的检测效果并不好；
* 第三行是本文模型，正确的检测了重叠的目标。


## 总结 by Piddnad
这篇文章的创新之处主要在于将图像分成网格，用LSTM在每个网格中单独预测物体，由此产生一个序列化的输出预测结果。这样一来，就获得了两个好处，一是直接输出一组不同的人物检测框，检测过度重叠的目标效果好，二是省去了常规的例如非极大值抑制的后处理步骤。
